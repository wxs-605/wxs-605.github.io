# 操作系统 八股文


## 操作系统的特征？

- **并发** 并发指的是两个或多个事件在同⼀时间间隔内发⽣，计算机系统中同时存在多个运⾏的程序，因此具有处理和调度多个程序同时执⾏的能⼒。
- **共享：** 系统中的资源可以供内存中多个并发执⾏的进程共同使⽤。
  - **互斥共享：** ⼀段时间内只允许⼀个进程访问该资源。⼀段时间内只允许⼀个进程访问的资源称为临界资源。
  - **同时访问：** ⼀段时间内允许多个进程“同时”访问，“同时”通常是宏观的，实际上是交替的对该资源进⾏访问。
- **虚拟**：把⼀个物理上的实体变为若⼲逻辑上的对应物。
- **异步：** 进程的执⾏并不是⼀贯到底的，⽽是以不可预知的速度向前推进。

## 线程和进程的区别？

1. **资源方面：** 进程是系统中拥有资源的基本单位，⽽线程不拥有系统资源（仅有⼀点必不可少的能保证运⾏的资源，⽐如寄存器和栈），但线程可以访问⾪属进程的系统资源。
2. **调度方面：** 线程切换的代价远低于进程，在同⼀个进程中，线程的切换不会引起进程切换，⽽从⼀个进程中的线程切换到另⼀个进程中的线程中，会引起进程切换。
3. **独立性方面：** 每个进程都拥有独⽴的地址空间和资源、除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程都不可⻅，同⼀进程中的不同线程是为了提⾼并发性以进⾏相互之间的合作⽽创建的，它们共享进程的地址空间和资源。
4. **系统开销方面：** 线程所需要的开销⽐进程⼩
   - 线程的创建时间⽐进程快，因为进程在创建的过程中，还需要资源管理信息，⽐如内存管理信息、⽂件管理信息，⽽线程在创建的过程中，不会涉及这些资源管理信息，⽽是共享它们；
   - 线程的终⽌时间⽐进程快，因为线程释放的资源相⽐进程少很多；
   - 同⼀个进程内的线程切换⽐进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同⼀个进程的线程都具有同⼀个⻚表，那么在切换的时候不需要切换⻚表。⽽对于进程之间的切换，切换的时候要把⻚表给切换掉，⽽⻚表的切换过程开销是⽐较⼤的。
   - 由于同⼀进程的各线程间共享内存和⽂件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更⾼。
5. **安全方面：** 由于进程之间相互隔离，一个进程的崩溃不会直接影响到其他进程的稳定性；而线程由于共享相同的内存空间，一个线程的错误可能会影响整个进程的稳定性。
6. **通信方面：** 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC(进程通信技术)进行通信。


## 进程间的通信方式有哪些？

总的来说，进程之间通信的方式有五种，分别是管道、消息队列、信号、信号量和共享内存和Socket。

### **管道通信：**

在Linux和类Unix系统中，管道是一种特殊的文件描述符，它可以连接一个进程的输出和另一个进程的输入，从而实现进程间的单向通信。管道通信又分为匿名管道和有名管道。
#### **匿名管道：**

一个单工的通信模式，具有固定的读端和写端，只能用于具有亲缘关系的进程之间通信，用完既销毁。匿名管道用 `fork()` 函数创建，可以将他看成一种特殊文件，对他的读写可以使用 read()，write() 函数；

#### **命名管道：**

该管道可通过路径名指出，在文件系统中可见，可以使两个相关的进程实现彼此通信，严格遵守先进先出的规则，在开始处读数据，末尾处写数据。命名管道用 `mkfifo()`函数创建；
   - 管道通信虽然简单，但是效率比较地，不适合进程间频繁地交换数据，并且管道智能传输无格式的字节流。
  
### **消息队列通信：**

当A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程在需要的时候自行去消息队列中读取数据就可以了。同样的，B 进程要给 A 进程发送消息也是如此。**消息队列的本质就是存放在内存中的消息的链表，** 而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。
   - 消息队列允许一个或多个进程向他写入或者读取信息；
   - 消息队列可以实现消息的随机查询，不一定非要以先进先出的次序读取消息，也可以按消息的类型读取。比有名管道的先进先出原则更有优势；
   - 消息队列对于**交换较少数量的数据**很有用，因为无需避免冲突。但是，由于用户进程写入数据到内存中的消息队列时，会发生从**用户态拷贝数据到内核态**的过程；同样的，另一个用户进程**读取内存中的消息数据时**，会发生**从内核态拷贝数据到用户态**的过程。因此，如果数据量较大，使用消息队列就会造成**频繁的系统调用**，也就是需要消耗更多的时间以便内核介入。

### **共享内存通信：**

共享内容可以很好的解决消息队列频繁的系统调用的问题。共享内存允许**不相干的进程**将**同一段物理内存**连接到它们**各自的地址空间**中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。如果某个进程向共享内存写入数据，所做的改动将**立即影响**到可以访问同一段共享内存的任何**其他进程**。

1.  每个进程都有属于自己的进程控制块（PCB）和逻辑地址空间（Addr Space），并且都有一个与之对应的页表，负责将进程的逻辑地址（虚拟地址）与物理地址进行映射，通过内存管理单元（MMU）进行管理。

2. **两个不同进程的逻辑地址通过页表映射到物理空间的同一区域，它们所共同指向的这块区域就是共享内存。**

3. 共享内存机制仅在建立共享内存区域时需要系统调用，一旦建立共享内存，所有的访问都可作为常规内存访问，无需借助内核。这样，数据就不需要在进程之间来回拷贝，所以这是最快的一种进程通信方式。

###  **信号量通信：**

信号量其实是⼀个**整型的计数器**，主要⽤于实现进程间的**互斥与同步**，⽽不是⽤于缓存进程间通信的**数据**。可以⽤来控制多个进程对共享资源的访问，常作为⼀种锁机制，防⽌某进程正在访问共享资源时，其他进程也访问该资源。因此主要作为进程间以及同⼀进程内不同线程之间的同步⼿段。

#### 控制信号量有两种操作，一种是**P操作**，一种是**V操作**：
   - **P 操作**，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏；
   - **V 操作**，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

###  **信号通信：**

⽤于通知接收进程某个事件已经发⽣，从⽽迫使进程执⾏信号处理程序，这也是一种信号通信的方式。**信号是进程通信机制中唯一的异步通信机制**，它可以在任何时候发送信号给某个进程。通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。用户、内核和进程都能生成和发送信号。

- 信号事件的来源主要有**硬件来源**和**软件来源**。
- 
- 所谓硬件来源就是说我们可以通过键盘输入某些组合键给进程发送信号，比如常见的组合键 Ctrl+C 产生 SIGINT 信号，表示终止该进程；
- 
- 而软件来源就是通过 kill 系列的命令给进程发送信号，比如 kill -9 1111 ，表示给 PID 为 1111 的进程发送 SIGKILL 信号，让其立即结束。可通过 `kill -l`命令查看所有信号；

### **Socket通信：**

上面介绍的5种方法都是用于同一台主机上的进程之间进行通信的，如果想要跨网络与不同主机上的进程进行通信就得使用 `Socket` 通信了。`Socket` 是支持TCP/IP的网络通信的基本操作单元，主要用于在客户端和服务器之间通过网络进行通信。
   
## 线程间的通信方式？

同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，⽐如全局变量，所以对于线程间关注的不是通信⽅式，⽽是关注多线程竞争共享资源的问题，**信号量**也同样可以在线程间实现**互斥与同步**：

1. **互斥锁：** 互斥锁是最常⻅的线程同步机制。它允许只有⼀个线程同时访问被保护的临界区（共享资源）；

2. **条件变量：** 条件变量⽤于线程间通信，允许⼀个线程等待某个条件满⾜，⽽其他线程可以发出信号通知等待线程。通常与互斥锁⼀起使⽤；

3. **读写锁：** 读写锁允许多个线程同时读取共享资源，但只允许⼀个线程写⼊资源；

4. **信号量：** ⽤于控制多个线程对共享资源进⾏访问的⼯具。

## 介绍一下你认识的锁？

锁是一个抽象概念，是一种**保护共享资源的同步化技术**。锁有两个操作：`acquire` 和 `release`。它一次最多只允许一个线程获取，一旦所有权被某一线程获取，其他线程只能等待该线程释放锁才能访问被保护的资源。

根据线程调度方式，可以将锁分为互斥锁和自旋锁；

### 互斥锁

一个 CPU 上面的多个线程抢占一把锁，抢占失败的线程会被调度器置位 `WAIT` （睡眠）状态，直到下一次的 CPU 时间片到来时再次抢占。互斥锁适用于加锁时间较长的场景，此时线程上下文切换带来的开销可以被忽略。

### 自旋锁

线程获取自旋锁失败后，不会放弃 CPU，会一直处于忙等待状态并持续检查锁是否被释放。适用于加锁时间小于线程切换开销的场景。

数据库中常见的两种锁是悲观锁和乐观锁。

### 悲观锁

悲观锁很悲观，它认为多线程同时修改共享资源的概率⽐较⾼，所以访问共享资源的时候先上锁；

### 乐观锁

乐观锁没有那么悲观，它假设数据一般情况不会造成冲突，即使当多用户同时修改数据后，只有一条被记录。当数据进行提交更新的时候，如果检测到数据不匹配，此时上报错误信息。乐观锁适用于读多写少的场景，这样可以提高程序的**吞吐量**。

最后一种是读写锁

### 读写锁

读写锁用于**对共享资源的访问**，它允许多个线程**同时读**共享资源，但在有线程要写共享资源时必须**互斥排斥**其他读者和写者。

读写锁有两种状态：**读模式和写模式**。在**读模式**下可以有多个线程同时访问共享资源，而在**写模式**下只能有一个线程访问共享资源。当有线程在写模式下访问共享资源时，所有其他线程（无论读模式还是写模式）都会被**阻塞**，直到写操作完成。

读写锁的好处是可以**提高读并发性能**。当共享资源被频繁读取而很少被写入时，读写锁可以允许更多线程并发地读取数据，从而提高系统的吞吐量和性能。

## 你知道死锁吗？什么情况下会产生死锁？

死锁是指两个或多个进程在争夺系统资源时，**由于互相等待对⽅释放资源**⽽⽆法继续执⾏的状态。死锁只有同时满⾜以下四个条件才会发⽣：

1. **互斥条件** ⼀个进程占⽤了某个资源时，其他进程⽆法同时占⽤该资源；
2. **请求和保持** 一个线程因为请求资源而阻塞的时候，不会释放自己的资源；
3. **不可剥夺条件** 资源不能被强制性地从⼀个进程中剥夺，只能由持有者⾃愿释放；
4. **环路等待条件** 多个进程之间形成⼀个循环等待资源的链，每个进程都在等待下⼀个进程所占有的资源；
